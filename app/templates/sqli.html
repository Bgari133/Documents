{% extends "base.html" %}
{% block title %}SQL Injection{% endblock %}
{% block content %}
<h1>SQL Injection – Hub</h1>
<p>Choose a lab below. Each endpoint is <strong>intentionally vulnerable</strong> for training. Run this app only in an isolated lab environment.</p>

<h2>SQL injection types (versions)</h2>
<table class="owasp-table">
    <thead><tr><th>Type</th><th>Route</th><th>Description</th></tr></thead>
    <tbody>
        <tr><td>Classic / In-band</td><td><a href="{{ url_for('sqli.search') }}">/sqli/search</a></td><td>Search by username; return all rows or trigger errors. Data returned in response.</td></tr>
        <tr><td>Error-based</td><td><a href="{{ url_for('sqli.error_based') }}">/sqli/error</a></td><td>Trigger SQL errors and use the error message to extract data (e.g. version, table names).</td></tr>
        <tr><td>Login bypass</td><td><a href="{{ url_for('sqli.login_bypass') }}">/sqli/login</a></td><td>Bypass authentication with <code>' OR '1'='1</code> in password.</td></tr>
        <tr><td>Union-based</td><td><a href="{{ url_for('sqli.union') }}">/sqli/union</a></td><td>Use <code>UNION SELECT</code> to dump passwords or other columns.</td></tr>
        <tr><td>Boolean blind</td><td><a href="{{ url_for('sqli.blind') }}">/sqli/blind</a></td><td>Only “User exists” / “Not found”; infer data one character at a time.</td></tr>
    </tbody>
</table>
<ul class="vuln-list">
    <li><a href="{{ url_for('sqli.search') }}">Classic / In-band</a> – Search; return all rows or trigger errors.</li>
    <li><a href="{{ url_for('sqli.error_based') }}">Error-based</a> – Use error messages to extract information.</li>
    <li><a href="{{ url_for('sqli.login_bypass') }}">Login bypass</a> – Bypass auth with <code>' OR '1'='1</code>.</li>
    <li><a href="{{ url_for('sqli.union') }}">Union-based</a> – <code>UNION SELECT</code> to dump data.</li>
    <li><a href="{{ url_for('sqli.blind') }}">Boolean blind</a> – Infer from true/false only.</li>
</ul>

<h2>How SQL injection works</h2>
<p>The server builds a SQL string by concatenating your input. If you close the string and add your own SQL, the database runs it.</p>

<h3>Vulnerable code (Python/Flask)</h3>
<pre class="code-example"><code>q = request.form.get("q", "")
cur = g.db.cursor()
sql = "SELECT id, username, email FROM users WHERE username = '" + q + "'"
cur.execute(sql)
rows = cur.fetchall()</code></pre>

<h3>What the attacker sends</h3>
<pre class="code-example"><code>' OR '1'='1</code></pre>

<h3>Resulting SQL</h3>
<pre class="code-example"><code>SELECT id, username, email FROM users WHERE username = '' OR '1'='1'</code></pre>
<p>The single quote in the input closes the string; <code>OR '1'='1'</code> is then interpreted as SQL, so the condition is always true and all rows are returned.</p>

<h3>Safe code (remediation)</h3>
<pre class="code-example"><code>q = request.form.get("q", "")
cur = g.db.cursor()
cur.execute("SELECT id, username, email FROM users WHERE username = ?", (q,))
rows = cur.fetchall()</code></pre>
<p>With a parameterized query, the input is passed as data, not as part of the SQL string. The database treats <code>' OR '1'='1</code> as a literal username and returns no rows.</p>

<h3>Login bypass example</h3>
<p>If the server builds: <code>WHERE username = 'u' AND password = 'p'</code>, the attacker can set password to <code>' OR '1'='1</code>. The resulting SQL becomes:</p>
<pre class="code-example"><code>SELECT * FROM users WHERE username = 'x' AND password = '' OR '1'='1'</code></pre>
<p>Because <code>OR '1'='1'</code> is true, the query returns a row and the attacker is “logged in”.</p>
{% endblock %}
